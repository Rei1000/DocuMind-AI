........F..F.FF.F.........F.F....s.s..............F.F...FF.F......FFFF.. [ 76%]
........F.F.F....F.F..                                                   [100%]
=================================== FAILURES ===================================
___________ TestDatabaseSchema.test_interest_groups_table_structure ____________

self = <test_database_schema.TestDatabaseSchema object at 0x10c7f1e80>

    def test_interest_groups_table_structure(self):
        """Test: Tabellenstruktur entspricht dem erwarteten Schema"""
        with engine.connect() as connection:
            # Hole Tabellenstruktur
            result = connection.execute(text("PRAGMA table_info(interest_groups)"))
            columns = result.fetchall()
    
            # Erwartete Spalten
            expected_columns = {
                'id': {'type': 'INTEGER', 'notnull': 1, 'pk': 1},
                'name': {'type': 'VARCHAR', 'notnull': 1, 'pk': 0},
                'code': {'type': 'VARCHAR', 'notnull': 1, 'pk': 0},
                'description': {'type': 'TEXT', 'notnull': 0, 'pk': 0},
                'group_permissions': {'type': 'TEXT', 'notnull': 0, 'pk': 0},
                'ai_functionality': {'type': 'TEXT', 'notnull': 0, 'pk': 0},
                'typical_tasks': {'type': 'TEXT', 'notnull': 0, 'pk': 0},
                'is_external': {'type': 'BOOLEAN', 'notnull': 1, 'pk': 0},
                'is_active': {'type': 'BOOLEAN', 'notnull': 1, 'pk': 0},
                'created_at': {'type': 'DATETIME', 'notnull': 1, 'pk': 0}
            }
    
            # Prüfe jede erwartete Spalte
            for col_name, expected in expected_columns.items():
                col_found = False
                for col in columns:
                    if col[1] == col_name:
                        col_found = True
                        # Prüfe Typ (vereinfacht)
>                       assert col[2].upper() in expected['type'].upper(), f"Spalte {col_name} hat falschen Typ: {col[2]}"
E                       AssertionError: Spalte name hat falschen Typ: VARCHAR(100)
E                       assert 'VARCHAR(100)' in 'VARCHAR'
E                        +  where 'VARCHAR(100)' = <built-in method upper of str object at 0x1113f0cf0>()
E                        +    where <built-in method upper of str object at 0x1113f0cf0> = 'VARCHAR(100)'.upper
E                        +  and   'VARCHAR' = <built-in method upper of str object at 0x10254e460>()
E                        +    where <built-in method upper of str object at 0x10254e460> = 'VARCHAR'.upper

tests/characterization/interestgroups/test_database_schema.py:61: AssertionError
__________ TestDatabaseSchema.test_interest_groups_unique_constraints __________

self = <test_database_schema.TestDatabaseSchema object at 0x10c7d0f80>

    def test_interest_groups_unique_constraints(self):
        """Test: Unique-Constraints sind korrekt definiert"""
        with engine.connect() as connection:
            # Prüfe Unique-Constraints
            result = connection.execute(text("PRAGMA index_list(interest_groups)"))
            indexes = result.fetchall()
    
            # Finde Unique-Indizes
            unique_indexes = []
            for idx in indexes:
                if idx[2] == 1:  # unique = 1
                    unique_indexes.append(idx[1])
    
            # name und code sollten unique sein
>           assert 'ix_interest_groups_name' in unique_indexes, "Name-Index ist nicht unique"
E           AssertionError: Name-Index ist nicht unique
E           assert 'ix_interest_groups_name' in ['ix_interest_groups_code_unique', 'ix_interest_groups_name_unique']

tests/characterization/interestgroups/test_database_schema.py:118: AssertionError
______________ TestDatabaseSchema.test_interest_group_data_types _______________

self = <test_database_schema.TestDatabaseSchema object at 0x10c9aa390>

    def test_interest_group_data_types(self):
        """Test: Datentypen sind korrekt implementiert"""
        with engine.connect() as connection:
            # Erstelle eine Test-Gruppe
            test_data = {
                'name': 'Test Group for Schema',
                'code': 'test_schema_group',
                'description': 'Test-Beschreibung',
                'group_permissions': '["test_perm1", "test_perm2"]',
                'ai_functionality': 'Test AI Funktionen',
                'typical_tasks': 'Test-Aufgaben',
                'is_external': False,
                'is_active': True
            }
    
            # Insert über SQL um Datentypen zu testen
            insert_sql = """
                INSERT INTO interest_groups
                (name, code, description, group_permissions, ai_functionality, typical_tasks, is_external, is_active)
                VALUES (:name, :code, :description, :group_permissions, :ai_functionality, :typical_tasks, :is_external, :is_active)
            """
    
            connection.execute(text(insert_sql), test_data)
            connection.commit()
    
            # Hole die eingefügten Daten zurück
            result = connection.execute(text("""
                SELECT * FROM interest_groups WHERE code = 'test_schema_group'
            """))
            row = result.fetchone()
    
            assert row is not None, "Test-Daten wurden nicht eingefügt"
    
            # Prüfe Datentypen
            assert isinstance(row[1], str), f"name sollte String sein, ist {type(row[1])}"
            assert isinstance(row[2], str), f"code sollte String sein, ist {type(row[2])}"
            assert isinstance(row[3], str) or row[3] is None, f"description sollte String oder None sein, ist {type(row[3])}"
            assert isinstance(row[4], str) or row[4] is None, f"group_permissions sollte String oder None sein, ist {type(row[4])}"
            assert isinstance(row[5], str) or row[5] is None, f"ai_functionality sollte String oder None sein, ist {type(row[5])}"
            assert isinstance(row[6], str) or row[6] is None, f"typical_tasks sollte String oder None sein, ist {type(row[6])}"
>           assert isinstance(row[7], bool), f"is_external sollte Boolean sein, ist {type(row[7])}"
E           AssertionError: is_external sollte Boolean sein, ist <class 'int'>
E           assert False
E            +  where False = isinstance(0, bool)

tests/characterization/interestgroups/test_database_schema.py:172: AssertionError
________ TestDatabaseSchema.test_interest_group_constraints_enforcement ________

self = <sqlalchemy.engine.base.Connection object at 0x11149b950>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x103639e50>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x11149a510>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x1114990a0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x103639e50>
cursor = <sqlite3.Cursor object at 0x1114857c0>
statement = "\n                INSERT INTO interest_groups (name, code, is_external, is_active)\n                VALUES ('First Group', 'unique_test_code', 0, 1)\n            "
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x11149a510>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: interest_groups.name

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: IntegrityError

The above exception was the direct cause of the following exception:

self = <test_database_schema.TestDatabaseSchema object at 0x10c9ab770>

    def test_interest_group_constraints_enforcement(self):
        """Test: Constraints werden von der Datenbank durchgesetzt"""
        with engine.connect() as connection:
            # Test 1: NOT NULL Constraint für name
            try:
                connection.execute(text("""
                    INSERT INTO interest_groups (code, is_external, is_active)
                    VALUES ('test_null_name', 0, 1)
                """))
                connection.commit()
                assert False, "NOT NULL Constraint für name wird nicht durchgesetzt"
            except Exception:
                # Erwartet: Exception wegen NOT NULL Constraint
                connection.rollback()
    
            # Test 2: NOT NULL Constraint für code
            try:
                connection.execute(text("""
                    INSERT INTO interest_groups (name, is_external, is_active)
                    VALUES ('Test Name', 0, 1)
                """))
                connection.commit()
                assert False, "NOT NULL Constraint für code wird nicht durchgesetzt"
            except Exception:
                # Erwartet: Exception wegen NOT NULL Constraint
                connection.rollback()
    
            # Test 3: Unique Constraint für code
            # Erst gültige Gruppe einfügen
>           connection.execute(text("""
                INSERT INTO interest_groups (name, code, is_external, is_active)
                VALUES ('First Group', 'unique_test_code', 0, 1)
            """))

tests/characterization/interestgroups/test_database_schema.py:209: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x103639e50>
cursor = <sqlite3.Cursor object at 0x1114857c0>
statement = "\n                INSERT INTO interest_groups (name, code, is_external, is_active)\n                VALUES ('First Group', 'unique_test_code', 0, 1)\n            "
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x11149a510>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: interest_groups.name
E       [SQL: 
E                       INSERT INTO interest_groups (name, code, is_external, is_active)
E                       VALUES ('First Group', 'unique_test_code', 0, 1)
E                   ]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: IntegrityError
______________ TestDatabaseSchema.test_interest_group_table_size _______________

self = <test_database_schema.TestDatabaseSchema object at 0x10c9abad0>

    def test_interest_group_table_size(self):
        """Test: Tabelle hat die erwartete Größe"""
        with engine.connect() as connection:
            # Zähle alle Einträge
            result = connection.execute(text("SELECT COUNT(*) FROM interest_groups"))
            count = result.fetchone()[0]
    
            # Mindestens die 13 Standard-Gruppen sollten existieren
>           assert count >= 13, f"Tabelle sollte mindestens 13 Einträge haben, hat aber {count}"
E           AssertionError: Tabelle sollte mindestens 13 Einträge haben, hat aber 11
E           assert 11 >= 13

tests/characterization/interestgroups/test_database_schema.py:273: AssertionError
________ TestDeleteInterestGroup.test_delete_interest_group_soft_delete ________

self = <test_delete_interest_group.TestDeleteInterestGroup object at 0x111310b00>
client = <starlette.testclient.TestClient object at 0x111539040>

    def test_delete_interest_group_soft_delete(self, client):
        """Test: Löschen ist ein Soft-Delete (is_active=False)"""
        # Erst eine Gruppe erstellen
        create_data = {
            "name": "Soft Delete Test Group",
            "code": "soft_delete_test_group",
            "description": "Test für Soft-Delete"
        }
    
        create_response = client.post("/api/interest-groups", json=create_data)
        assert create_response.status_code == 200
        created_group = create_response.json()
        group_id = created_group["id"]
    
        # Gruppe löschen
        delete_response = client.delete(f"/api/interest-groups/{group_id}")
        assert delete_response.status_code == 200
    
        # Gruppe sollte noch in der Datenbank existieren, aber is_active=False haben
        # Da der GET-Endpunkt nur aktive Gruppen zurückgibt, sollte 404 zurückkommen
        get_response = client.get(f"/api/interest-groups/{group_id}")
>       assert get_response.status_code == 404
E       assert 200 == 404
E        +  where 200 = <Response [200 OK]>.status_code

tests/characterization/interestgroups/test_delete_interest_group.py:107: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-09-04 12:31:27,147 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
2025-09-04 12:31:27,149 [INFO] [httpx] HTTP Request: DELETE http://testserver/api/interest-groups/14 "HTTP/1.1 200 OK"
2025-09-04 12:31:27,150 [INFO] [httpx] HTTP Request: GET http://testserver/api/interest-groups/14 "HTTP/1.1 200 OK"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: DELETE http://testserver/api/interest-groups/14 "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/api/interest-groups/14 "HTTP/1.1 200 OK"
____ TestDeleteInterestGroup.test_delete_interest_group_multiple_deletions _____

self = <test_delete_interest_group.TestDeleteInterestGroup object at 0x111310c80>
client = <starlette.testclient.TestClient object at 0x11149b950>

    def test_delete_interest_group_multiple_deletions(self, client):
        """Test: Mehrfache Löschungen der gleichen Gruppe"""
        # Erst eine Gruppe erstellen
        create_data = {
            "name": "Multiple Delete Test Group",
            "code": "multiple_delete_test",
            "description": "Test für mehrfache Löschungen"
        }
    
        create_response = client.post("/api/interest-groups", json=create_data)
        assert create_response.status_code == 200
        created_group = create_response.json()
        group_id = created_group["id"]
    
        # Gruppe zum ersten Mal löschen
        first_delete = client.delete(f"/api/interest-groups/{group_id}")
        assert first_delete.status_code == 200
    
        # Gruppe zum zweiten Mal löschen (sollte 404 zurückgeben)
        second_delete = client.delete(f"/api/interest-groups/{group_id}")
    
        # Bestehendes Verhalten: 404 für bereits gelöschte Gruppen
>       assert second_delete.status_code == 404
E       assert 200 == 404
E        +  where 200 = <Response [200 OK]>.status_code

tests/characterization/interestgroups/test_delete_interest_group.py:166: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-09-04 12:31:27,161 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
2025-09-04 12:31:27,163 [INFO] [httpx] HTTP Request: DELETE http://testserver/api/interest-groups/16 "HTTP/1.1 200 OK"
2025-09-04 12:31:27,165 [INFO] [httpx] HTTP Request: DELETE http://testserver/api/interest-groups/16 "HTTP/1.1 200 OK"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: DELETE http://testserver/api/interest-groups/16 "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: DELETE http://testserver/api/interest-groups/16 "HTTP/1.1 200 OK"
______ TestInterestGroupBusinessRules.test_interest_group_entity_creation ______

self = <test_interest_group_business_rules.TestInterestGroupBusinessRules object at 0x1113440b0>

    def test_interest_group_entity_creation(self):
        """Test: InterestGroup Entity kann erstellt werden (Legacy vs DDD)"""
        timestamp = int(time.time())
    
        # Test mit minimalen Daten
        payload = ig_payload(
            code=f"test_business_group_{timestamp}",
            name="Test Business Group",
            perms_input=None
        )
    
        # Legacy-Lauf: Frische DB erstellen
        legacy_db_path = f".tmp/perm_legacy_{timestamp}.db"
        make_fresh_db_at(legacy_db_path)
        set_env_db(legacy_db_path)
    
        # Legacy-Create
        legacy_status, legacy_body = run_legacy(
            "backend.app.main:app",
            legacy_db_path,
            "POST",
            "/api/interest-groups",
            json_data=payload
        )
    
        # DDD-Lauf: Frische DB erstellen
        ddd_db_path = f".tmp/perm_ddd_{timestamp}.db"
        make_fresh_db_at(ddd_db_path)
        set_env_db(ddd_db_path)
    
        # DDD-Create (mit anderem Code für frischen DB-Zustand)
        ddd_payload = ig_payload(
            code=f"ddd_test_business_group_{timestamp}",
            name="Test Business Group",  # Gleicher Name wie Legacy
            perms_input=None
        )
    
        ddd_status, ddd_body = run_ddd(
            "backend.app.main:app",
            ddd_db_path,
            "POST",
            "/api/interest-groups",
            json_data=ddd_payload
        )
    
        # Parität: Beide Modi sollten identischen Statuscode zurückgeben
>       assert legacy_status == ddd_status, \
            f"Entity Creation Statuscode-Parität verletzt: Legacy={legacy_status}, DDD={ddd_status}"
E       AssertionError: Entity Creation Statuscode-Parität verletzt: Legacy=200, DDD=500
E       assert 200 == 500

tests/characterization/interestgroups/test_interest_group_business_rules.py:77: AssertionError
----------------------------- Captured stdout call -----------------------------
[SCHEMA-EXTRAS] applied=true tables=
[SCHEMA-EXTRAS] applied=true tables=
✅ Advanced RAG Engine (Enterprise Grade) erfolgreich geladen
🚀 Features: Hierarchical Chunking, LangChain, Enhanced Metadata
⚠️  AI-Enhanced Features nicht verfügbar: cannot import name 'upload_document_with_ai' from 'backend.app.ai_endpoints' (/Users/reiner/Documents/DocuMind-AI/backend/app/ai_endpoints.py)
⚠️ Enhanced AI System nicht verfügbar: No module named 'schemas_enhanced'
✅ Advanced AI System (Enterprise Grade) geladen
🚀 Features: Hierarchical Chunking, Multi-Layer Analysis, Query Enhancement
[ROUTING] mode=legacy for /api/interest-groups
[RUNTIME] mode=legacy url=sqlite:///.tmp/perm_legacy_1756981887.db
[RUNTIME] tables=4 first=interest_groups
[SCHEMA-EXTRAS] applied=true tables=
[SCHEMA-EXTRAS] applied=true tables=
✅ Advanced RAG Engine (Enterprise Grade) erfolgreich geladen
🚀 Features: Hierarchical Chunking, LangChain, Enhanced Metadata
⚠️  AI-Enhanced Features nicht verfügbar: cannot import name 'upload_document_with_ai' from 'backend.app.ai_endpoints' (/Users/reiner/Documents/DocuMind-AI/backend/app/ai_endpoints.py)
⚠️ Enhanced AI System nicht verfügbar: No module named 'schemas_enhanced'
✅ Advanced AI System (Enterprise Grade) geladen
🚀 Features: Hierarchical Chunking, Multi-Layer Analysis, Query Enhancement
✅ DDD+Hex Interest Groups Router aktiviert
[ROUTING] mode=ddd for /api/interest-groups
[RUNTIME] mode=ddd url=sqlite:///.tmp/perm_ddd_1756981887.db
[RUNTIME] tables=4 first=interest_groups
[EXC] type=HTTPException msg=Interest group with name 'Test Business Group' already exists status=500
----------------------------- Captured stderr call -----------------------------
2025-09-04 12:31:27,916 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
2025-09-04 12:31:27,983 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
2025-09-04 12:31:27,985 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 500 Internal Server Error"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 500 Internal Server Error"
__________ TestInterestGroupDataTypes.test_interest_group_data_types ___________

self = <sqlalchemy.engine.base.Connection object at 0x115e01cd0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x103639e50>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x111ecb6e0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x11149a3f0>
parameters = [('Test Group for Schema', 'test_schema_group', 'Test-Beschreibung', '["test_perm1", "test_perm2"]', 'Test AI Funktionen', 'Test-Aufgaben', ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x103639e50>
cursor = <sqlite3.Cursor object at 0x1119f2cc0>
statement = '\n                INSERT INTO interest_groups \n                (name, code, description, group_permissions, ai_functionality, typical_tasks, is_external, is_active)\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n            '
parameters = ('Test Group for Schema', 'test_schema_group', 'Test-Beschreibung', '["test_perm1", "test_perm2"]', 'Test AI Funktionen', 'Test-Aufgaben', ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x111ecb6e0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: interest_groups.code

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: IntegrityError

The above exception was the direct cause of the following exception:

self = <test_interest_group_data_types.TestInterestGroupDataTypes object at 0x1113446e0>

    def test_interest_group_data_types(self):
        """Test: Datentypen sind korrekt implementiert"""
        with engine.connect() as connection:
            # Erstelle eine Test-Gruppe
            test_data = {
                'name': 'Test Group for Schema',
                'code': 'test_schema_group',
                'description': 'Test-Beschreibung',
                'group_permissions': '["test_perm1", "test_perm2"]',
                'ai_functionality': 'Test AI Funktionen',
                'typical_tasks': 'Test-Aufgaben',
                'is_external': False,
                'is_active': True
            }
    
            # Insert über SQL um Datentypen zu testen
            insert_sql = """
                INSERT INTO interest_groups
                (name, code, description, group_permissions, ai_functionality, typical_tasks, is_external, is_active)
                VALUES (:name, :code, :description, :group_permissions, :ai_functionality, :typical_tasks, :is_external, :is_active)
            """
    
>           connection.execute(text(insert_sql), test_data)

tests/characterization/interestgroups/test_interest_group_data_types.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x103639e50>
cursor = <sqlite3.Cursor object at 0x1119f2cc0>
statement = '\n                INSERT INTO interest_groups \n                (name, code, description, group_permissions, ai_functionality, typical_tasks, is_external, is_active)\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n            '
parameters = ('Test Group for Schema', 'test_schema_group', 'Test-Beschreibung', '["test_perm1", "test_perm2"]', 'Test AI Funktionen', 'Test-Aufgaben', ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x111ecb6e0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: interest_groups.code
E       [SQL: 
E                       INSERT INTO interest_groups 
E                       (name, code, description, group_permissions, ai_functionality, typical_tasks, is_external, is_active)
E                       VALUES (?, ?, ?, ?, ?, ?, ?, ?)
E                   ]
E       [parameters: ('Test Group for Schema', 'test_schema_group', 'Test-Beschreibung', '["test_perm1", "test_perm2"]', 'Test AI Funktionen', 'Test-Aufgaben', False, True)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: IntegrityError
___________ TestEndpointParity.test_get_interest_group_by_id_parity ____________

self = <test_parity_endpoints.TestEndpointParity object at 0x111344a40>
client = <starlette.testclient.TestClient object at 0x111af2690>

    def test_get_interest_group_by_id_parity(self, client):
        """Test: GET /api/interest-groups/{id} - Legacy vs. DDD"""
        # Erst eine Gruppe erstellen für den Test
        create_data = {
            "name": "Parity Test Group",
            "code": "parity_test_group",
            "description": "Test für Paritäts-Vergleich"
        }
    
        create_response = run_request(
            client, "legacy", "POST", "/api/interest-groups", json_data=create_data
        )
>       assert create_response[0] == 200, f"Gruppe konnte nicht erstellt werden: {create_response[0]}"
E       AssertionError: Gruppe konnte nicht erstellt werden: 409
E       assert 409 == 200

tests/characterization/interestgroups/test_parity_endpoints.py:47: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-09-04 12:31:28,889 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
_____________ TestEndpointParity.test_create_interest_group_parity _____________

self = <test_parity_endpoints.TestEndpointParity object at 0x111344950>
client = <starlette.testclient.TestClient object at 0x111689d60>

    def test_create_interest_group_parity(self, client):
        """Test: POST /api/interest-groups - Legacy vs. DDD"""
        # Verwende eindeutige Payload für jeden Request
        import time
        timestamp = int(time.time())
    
        # Erst eine Gruppe erstellen (Legacy)
        create_data = {
            "name": f"Create Parity Test {timestamp}",
            "code": f"create_parity_test_{timestamp}",
            "description": "Test für Create-Parität"
        }
    
        create_response = run_request(
            client, "legacy", "POST", "/api/interest-groups", json_data=create_data
        )
        assert create_response[0] == 200, f"Gruppe konnte nicht erstellt werden: {create_response[0]}"
    
        # Jetzt den gleichen POST in beiden Modi testen (beide sollten 200 zurückgeben)
        # Legacy-Request (Duplicate)
        legacy_response = run_request(
            client, "legacy", "POST", "/api/interest-groups", json_data=create_data
        )
    
        # DDD-Request (Duplicate)
        ddd_response = run_request(
            client, "ddd", "POST", "/api/interest-groups", json_data=create_data
        )
    
        # Vergleich
        comparison = compare_responses(legacy_response, ddd_response)
    
        # Assertions - beide sollten 200 zurückgeben (Legacy-Kompatibilität)
        assert comparison["status_equal"], f"Status unterscheidet sich: {comparison['status_diff']}"
>       assert legacy_response[0] == 200, f"Legacy sollte 200 zurückgeben, aber gab {legacy_response[0]} zurück"
E       AssertionError: Legacy sollte 200 zurückgeben, aber gab 409 zurück
E       assert 409 == 200

tests/characterization/interestgroups/test_parity_endpoints.py:106: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-09-04 12:31:28,894 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
2025-09-04 12:31:28,895 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
2025-09-04 12:31:28,896 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
_____________ TestEndpointParity.test_delete_interest_group_parity _____________

self = <test_parity_endpoints.TestEndpointParity object at 0x111345220>
client = <starlette.testclient.TestClient object at 0x111e495b0>

    def test_delete_interest_group_parity(self, client):
        """Test: DELETE /api/interest-groups/{id} - Legacy vs. DDD"""
        # Erst eine Gruppe erstellen
        create_data = {
            "name": "Delete Parity Test",
            "code": "delete_parity_test",
            "description": "Test für Delete-Parität"
        }
    
        create_response = run_request(
            client, "legacy", "POST", "/api/interest-groups", json_data=create_data
        )
>       assert create_response[0] == 200, f"Gruppe konnte nicht erstellt werden: {create_response[0]}"
E       AssertionError: Gruppe konnte nicht erstellt werden: 409
E       assert 409 == 200

tests/characterization/interestgroups/test_parity_endpoints.py:167: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-09-04 12:31:28,909 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
______________ TestPermissionParity.test_empty_permissions_parity ______________

self = <test_permission_parity.TestPermissionParity object at 0x111346480>
client = <starlette.testclient.TestClient object at 0x115e1f980>

    def test_empty_permissions_parity(self, client):
        """Test: Leere Permissions werden identisch behandelt"""
        create_data = {
            "name": "Empty Permissions Test",
            "code": "empty_permissions_test",
            "description": "Test für leere Permissions",
            "group_permissions": []  # Leere Liste
        }
    
        print("Teste leere Permissions...")
    
        # Legacy-Create
        legacy_create = run_request(
            client, "legacy", "POST", "/api/interest-groups", json_data=create_data
        )
    
        # DDD-Create
        ddd_create = run_request(
            client, "ddd", "POST", "/api/interest-groups", json_data=create_data
        )
    
        # Vergleich
        create_comparison = compare_responses(legacy_create, ddd_create)
        print(f"Create mit leeren Permissions: {format_comparison_result(create_comparison)}")
    
        # Statuscodes müssen identisch sein
>       assert create_comparison["status_equal"], f"Create-Status unterscheidet sich: {create_comparison['status_diff']}"
E       AssertionError: Create-Status unterscheidet sich: {'legacy': 200, 'ddd': 409}
E       assert False

tests/characterization/interestgroups/test_permission_parity.py:39: AssertionError
----------------------------- Captured stdout call -----------------------------
Teste leere Permissions...
Create mit leeren Permissions: ❌ ABWEICHUNG: Status: 200→409 | Body unterscheidet sich | Headers unterscheiden sich
----------------------------- Captured stderr call -----------------------------
2025-09-04 12:31:30,067 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
2025-09-04 12:31:30,068 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
_____________ TestPermissionParity.test_simple_permissions_parity ______________

self = <test_permission_parity.TestPermissionParity object at 0x111346690>
client = <starlette.testclient.TestClient object at 0x111af4800>

    def test_simple_permissions_parity(self, client):
        """Test: Einfache Permissions werden identisch behandelt"""
        create_data = {
            "name": "Simple Permissions Test",
            "code": "simple_permissions_test",
            "description": "Test für einfache Permissions",
            "group_permissions": ["VIEW", "EDIT"]  # Einfache Liste
        }
    
        print("Teste einfache Permissions...")
    
        # Legacy-Create
        legacy_create = run_request(
            client, "legacy", "POST", "/api/interest-groups", json_data=create_data
        )
    
        # DDD-Create
        ddd_create = run_request(
            client, "ddd", "POST", "/api/interest-groups", json_data=create_data
        )
    
        # Vergleich
        create_comparison = compare_responses(legacy_create, ddd_create)
        print(f"Create mit einfachen Permissions: {format_comparison_result(create_comparison)}")
    
        # Statuscodes müssen identisch sein
>       assert create_comparison["status_equal"], f"Create-Status unterscheidet sich: {create_comparison['status_diff']}"
E       AssertionError: Create-Status unterscheidet sich: {'legacy': 200, 'ddd': 409}
E       assert False

tests/characterization/interestgroups/test_permission_parity.py:107: AssertionError
----------------------------- Captured stdout call -----------------------------
Teste einfache Permissions...
Create mit einfachen Permissions: ❌ ABWEICHUNG: Status: 200→409 | Body unterscheidet sich | Headers unterscheiden sich
----------------------------- Captured stderr call -----------------------------
2025-09-04 12:31:30,074 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
2025-09-04 12:31:30,076 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
_____________ TestPermissionParity.test_complex_permissions_parity _____________

self = <test_permission_parity.TestPermissionParity object at 0x1113468a0>
client = <starlette.testclient.TestClient object at 0x1169ec3b0>

    def test_complex_permissions_parity(self, client):
        """Test: Komplexe Permissions werden identisch behandelt"""
        create_data = {
            "name": "Complex Permissions Test",
            "code": "complex_permissions_test",
            "description": "Test für komplexe Permissions",
            "group_permissions": ["VIEW", "EDIT", "DELETE", "APPROVE", "ADMIN"]  # Komplexe Liste
        }
    
        print("Teste komplexe Permissions...")
    
        # Legacy-Create
        legacy_create = run_request(
            client, "legacy", "POST", "/api/interest-groups", json_data=create_data
        )
    
        # DDD-Create
        ddd_create = run_request(
            client, "ddd", "POST", "/api/interest-groups", json_data=create_data
        )
    
        # Vergleich
        create_comparison = compare_responses(legacy_create, ddd_create)
        print(f"Create mit komplexen Permissions: {format_comparison_result(create_comparison)}")
    
        # Statuscodes müssen identisch sein
>       assert create_comparison["status_equal"], f"Create-Status unterscheidet sich: {create_comparison['status_diff']}"
E       AssertionError: Create-Status unterscheidet sich: {'legacy': 200, 'ddd': 409}
E       assert False

tests/characterization/interestgroups/test_permission_parity.py:175: AssertionError
----------------------------- Captured stdout call -----------------------------
Teste komplexe Permissions...
Create mit komplexen Permissions: ❌ ABWEICHUNG: Status: 200→409 | Body unterscheidet sich | Headers unterscheiden sich
----------------------------- Captured stderr call -----------------------------
2025-09-04 12:31:30,080 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
2025-09-04 12:31:30,081 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
___________ TestPermissionParity.test_json_string_permissions_parity ___________

self = <test_permission_parity.TestPermissionParity object at 0x111346ab0>
client = <starlette.testclient.TestClient object at 0x1169ed100>

    def test_json_string_permissions_parity(self, client):
        """Test: JSON-String Permissions werden identisch behandelt"""
        # JSON-String als group_permissions
        json_permissions = '["VIEW", "EDIT", "DELETE"]'
    
        create_data = {
            "name": "JSON String Permissions Test",
            "code": "json_string_permissions_test",
            "description": "Test für JSON-String Permissions",
            "group_permissions": json_permissions
        }
    
        print(f"Teste JSON-String Permissions: {json_permissions}")
    
        # Legacy-Create
        legacy_create = run_request(
            client, "legacy", "POST", "/api/interest-groups", json_data=create_data
        )
    
        # DDD-Create
        ddd_create = run_request(
            client, "ddd", "POST", "/api/interest-groups", json_data=create_data
        )
    
        # Vergleich
        create_comparison = compare_responses(legacy_create, ddd_create)
        print(f"Create mit JSON-String Permissions: {format_comparison_result(create_comparison)}")
    
        # Statuscodes müssen identisch sein
>       assert create_comparison["status_equal"], f"Create-Status unterscheidet sich: {create_comparison['status_diff']}"
E       AssertionError: Create-Status unterscheidet sich: {'legacy': 200, 'ddd': 409}
E       assert False

tests/characterization/interestgroups/test_permission_parity.py:246: AssertionError
----------------------------- Captured stdout call -----------------------------
Teste JSON-String Permissions: ["VIEW", "EDIT", "DELETE"]
Create mit JSON-String Permissions: ❌ ABWEICHUNG: Status: 200→409 | Body unterscheidet sich | Headers unterscheiden sich
----------------------------- Captured stderr call -----------------------------
2025-09-04 12:31:30,087 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
2025-09-04 12:31:30,088 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
____________ TestStatuscodeParity.test_duplicate_constraints_parity ____________

self = <sqlalchemy.engine.base.Connection object at 0x1117c6e70>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x103639e50>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1115f6c60>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x10be237a0>
parameters = [('Duplicate Test Group', 'different_code', 'Andere Beschreibung', '[]', None, None, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x103639e50>
cursor = <sqlite3.Cursor object at 0x1118b8bc0>
statement = 'INSERT INTO interest_groups (name, code, description, group_permissions, ai_functionality, typical_tasks, is_external, is_active, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Duplicate Test Group', 'different_code', 'Andere Beschreibung', '[]', None, None, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1115f6c60>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: interest_groups.name

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: IntegrityError

The above exception was the direct cause of the following exception:

self = <test_statuscode_parity.TestStatuscodeParity object at 0x11137c1a0>
client = <starlette.testclient.TestClient object at 0x1117c4710>

    def test_duplicate_constraints_parity(self, client):
        """Test: Duplicate-Constraints - Legacy vs. DDD"""
        print("Teste Duplicate-Constraints...")
    
        # Erst eine Gruppe erstellen
        create_data = {
            "name": "Duplicate Test Group",
            "code": "duplicate_test_code",
            "description": "Test für Duplicate-Constraints"
        }
    
        create_response = run_request(
            client, "legacy", "POST", "/api/interest-groups", json_data=create_data
        )
        assert create_response[0] == 200, f"Gruppe konnte nicht erstellt werden: {create_response[0]}"
    
        # Versuche, eine Gruppe mit gleichem Namen zu erstellen
        duplicate_name_data = {
            "name": "Duplicate Test Group",  # Gleicher Name
            "code": "different_code",
            "description": "Andere Beschreibung"
        }
    
        # Legacy-Request
>       legacy_response = run_request(
            client, "legacy", "POST", "/api/interest-groups", json_data=duplicate_name_data
        )

tests/characterization/interestgroups/test_statuscode_parity.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers/ab_runner.py:284: in run_request
    response = client.request(**request_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/starlette/testclient.py:484: in request
    return super().request(
venv/lib/python3.12/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
venv/lib/python3.12/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
venv/lib/python3.12/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/starlette/testclient.py:377: in handle_request
    raise exc
venv/lib/python3.12/site-packages/starlette/testclient.py:374: in handle_request
    portal.call(self.app, scope, receive, send)
venv/lib/python3.12/site-packages/anyio/from_thread.py:290: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:456: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
venv/lib/python3.12/site-packages/anyio/from_thread.py:221: in _call_func
    retval = await retval_or_awaitable
             ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/fastapi/applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:187: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:165: in __call__
    await self.app(scope, receive, _send)
venv/lib/python3.12/site-packages/starlette/middleware/cors.py:85: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:62: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
venv/lib/python3.12/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
venv/lib/python3.12/site-packages/starlette/routing.py:715: in __call__
    await self.middleware_stack(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:735: in app
    await route.handle(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:288: in handle
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:76: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
venv/lib/python3.12/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
venv/lib/python3.12/site-packages/starlette/routing.py:73: in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/fastapi/routing.py:301: in app
    raw_response = await run_endpoint_function(
venv/lib/python3.12/site-packages/fastapi/routing.py:212: in run_endpoint_function
    return await dependant.call(**values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
backend/app/main.py:939: in create_interest_group
    db.commit()
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2028: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4352: in flush
    self._flush(objects)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4487: in _flush
    with util.safe_reraise():
venv/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4448: in _flush
    flush_context.execute()
venv/lib/python3.12/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
venv/lib/python3.12/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
venv/lib/python3.12/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x103639e50>
cursor = <sqlite3.Cursor object at 0x1118b8bc0>
statement = 'INSERT INTO interest_groups (name, code, description, group_permissions, ai_functionality, typical_tasks, is_external, is_active, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('Duplicate Test Group', 'different_code', 'Andere Beschreibung', '[]', None, None, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1115f6c60>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: interest_groups.name
E       [SQL: INSERT INTO interest_groups (name, code, description, group_permissions, ai_functionality, typical_tasks, is_external, is_active, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('Duplicate Test Group', 'different_code', 'Andere Beschreibung', '[]', None, None, 0, 1, '2025-09-04 10:31:30.191812')]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: IntegrityError
----------------------------- Captured stdout call -----------------------------
Teste Duplicate-Constraints...
----------------------------- Captured stderr call -----------------------------
2025-09-04 12:31:30,190 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
____________ TestStatuscodeParity.test_invalid_content_type_parity _____________

self = <test_statuscode_parity.TestStatuscodeParity object at 0x11137c5c0>
client = <starlette.testclient.TestClient object at 0x111803590>

    def test_invalid_content_type_parity(self, client):
        """Test: Ungültiger Content-Type - Legacy vs. DDD"""
        print("Teste ungültigen Content-Type...")
    
        # Test mit form-data statt JSON
        form_data = {
            "name": "Form Data Test",
            "code": "form_data_test",
            "description": "Test mit form-data"
        }
    
        # Legacy-Request mit form-data
        legacy_response = run_request(
            client, "legacy", "POST", "/api/interest-groups",
            json_data=None,  # Kein JSON
            headers={"Content-Type": "application/x-www-form-urlencoded"}
        )
    
        # DDD-Request mit form-data
        ddd_response = run_request(
            client, "ddd", "POST", "/api/interest-groups",
            json_data=None,  # Kein JSON
            headers={"Content-Type": "application/x-www-form-urlencoded"}
        )
    
        # Vergleich
        comparison = compare_responses(legacy_response, ddd_response)
        print(f"Form-data Content-Type: {format_comparison_result(comparison)}")
    
        # Statuscodes müssen identisch sein
        assert comparison["status_equal"], f"Status unterscheidet sich: {comparison['status_diff']}"
    
        # Test ohne Content-Type Header
        legacy_response = run_request(
            client, "legacy", "POST", "/api/interest-groups",
            json_data={"name": "No Content Type", "code": "no_content_type"}
        )
    
        ddd_response = run_request(
            client, "ddd", "POST", "/api/interest-groups",
            json_data={"name": "No Content Type", "code": "no_content_type"}
        )
    
        # Vergleich
        comparison = compare_responses(legacy_response, ddd_response)
        print(f"Kein Content-Type Header: {format_comparison_result(comparison)}")
    
        # Statuscodes müssen identisch sein
>       assert comparison["status_equal"], f"Status unterscheidet sich: {comparison['status_diff']}"
E       AssertionError: Status unterscheidet sich: {'legacy': 200, 'ddd': 409}
E       assert False

tests/characterization/interestgroups/test_statuscode_parity.py:245: AssertionError
----------------------------- Captured stdout call -----------------------------
Teste ungültigen Content-Type...
Form-data Content-Type: ✅ IDENTISCH
Kein Content-Type Header: ❌ ABWEICHUNG: Status: 200→409 | Body unterscheidet sich | Headers unterscheiden sich
----------------------------- Captured stderr call -----------------------------
2025-09-04 12:31:30,613 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 422 Unprocessable Entity"
2025-09-04 12:31:30,614 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 422 Unprocessable Entity"
2025-09-04 12:31:30,616 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
2025-09-04 12:31:30,618 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 422 Unprocessable Entity"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 422 Unprocessable Entity"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
_________________ TestStatuscodeParity.test_edge_cases_parity __________________

self = <test_statuscode_parity.TestStatuscodeParity object at 0x11137c9e0>
client = <starlette.testclient.TestClient object at 0x11149b4d0>

    def test_edge_cases_parity(self, client):
        """Test: Edge-Cases - Legacy vs. DDD"""
        print("Teste Edge-Cases...")
    
        # Test mit leeren Strings
        empty_strings_data = {
            "name": "",  # Leerer String
            "code": "",  # Leerer String
            "description": ""  # Leerer String
        }
    
        # Legacy-Request
        legacy_response = run_request(
            client, "legacy", "POST", "/api/interest-groups", json_data=empty_strings_data
        )
    
        # DDD-Request
        ddd_response = run_request(
            client, "ddd", "POST", "/api/interest-groups", json_data=empty_strings_data
        )
    
        # Vergleich
        comparison = compare_responses(legacy_response, ddd_response)
        print(f"Leere Strings: {format_comparison_result(comparison)}")
    
        # Statuscodes müssen identisch sein
        assert comparison["status_equal"], f"Status unterscheidet sich: {comparison['status_diff']}"
    
        # Test mit None-Werten
        none_values_data = {
            "name": "None Values Test",
            "code": "none_values_test",
            "description": None,  # None-Wert
            "group_permissions": None,  # None-Wert
            "ai_functionality": None,  # None-Wert
            "typical_tasks": None  # None-Wert
        }
    
        # Legacy-Request
        legacy_response = run_request(
            client, "legacy", "POST", "/api/interest-groups", json_data=none_values_data
        )
    
        # DDD-Request
        ddd_response = run_request(
            client, "ddd", "POST", "/api/interest-groups", json_data=none_values_data
        )
    
        # Vergleich
        comparison = compare_responses(legacy_response, ddd_response)
        print(f"None-Werte: {format_comparison_result(comparison)}")
    
        # Statuscodes müssen identisch sein
>       assert comparison["status_equal"], f"Status unterscheidet sich: {comparison['status_diff']}"
E       AssertionError: Status unterscheidet sich: {'legacy': 200, 'ddd': 409}
E       assert False

tests/characterization/interestgroups/test_statuscode_parity.py:377: AssertionError
----------------------------- Captured stdout call -----------------------------
Teste Edge-Cases...
Leere Strings: ✅ IDENTISCH
None-Werte: ❌ ABWEICHUNG: Status: 200→409 | Body unterscheidet sich | Headers unterscheiden sich
----------------------------- Captured stderr call -----------------------------
2025-09-04 12:31:30,628 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 422 Unprocessable Entity"
2025-09-04 12:31:30,629 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 422 Unprocessable Entity"
2025-09-04 12:31:30,632 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
2025-09-04 12:31:30,633 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 422 Unprocessable Entity"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 422 Unprocessable Entity"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 409 Conflict"
_____ TestUpdateInterestGroup.test_update_interest_group_validation_rules ______

self = <test_update_interest_group.TestUpdateInterestGroup object at 0x11137c500>
client = <starlette.testclient.TestClient object at 0x111aa6f60>

    def test_update_interest_group_validation_rules(self, client):
        """Test: Validierungsregeln gelten auch bei Updates"""
        # Erst eine Gruppe erstellen
        create_data = {
            "name": "Validation Test Group",
            "code": "validation_test_group",
            "description": "Test"
        }
    
        create_response = client.post("/api/interest-groups", json=create_data)
        assert create_response.status_code == 200
        created_group = create_response.json()
        group_id = created_group["id"]
    
        # Test mit zu kurzem Namen
        short_name_update = {
            "name": "A"  # Zu kurz (min 2 Zeichen)
        }
    
        response = client.put(f"/api/interest-groups/{group_id}", json=short_name_update)
    
        # Bestehendes Verhalten: 422 für ungültige Namen
        assert response.status_code == 422
    
        # Test mit zu langem Namen
        long_name_update = {
            "name": "A" * 101  # Zu lang (max 100 Zeichen)
        }
    
        response = client.put(f"/api/interest-groups/{group_id}", json=long_name_update)
    
        # Bestehendes Verhalten: 422 für zu lange Namen
        assert response.status_code == 422
    
        # Test mit ungültigem Code-Format
        invalid_code_update = {
            "code": "InvalidCode"  # Sollte snake_case sein
        }
    
>       response = client.put(f"/api/interest-groups/{group_id}", json=invalid_code_update)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/characterization/interestgroups/test_update_interest_group.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/starlette/testclient.py:626: in put
    return super().put(
venv/lib/python3.12/site-packages/httpx/_client.py:1181: in put
    return self.request(
venv/lib/python3.12/site-packages/starlette/testclient.py:484: in request
    return super().request(
venv/lib/python3.12/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
venv/lib/python3.12/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
venv/lib/python3.12/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/starlette/testclient.py:377: in handle_request
    raise exc
venv/lib/python3.12/site-packages/starlette/testclient.py:374: in handle_request
    portal.call(self.app, scope, receive, send)
venv/lib/python3.12/site-packages/anyio/from_thread.py:290: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:456: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
venv/lib/python3.12/site-packages/anyio/from_thread.py:221: in _call_func
    retval = await retval_or_awaitable
             ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/fastapi/applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:187: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:165: in __call__
    await self.app(scope, receive, _send)
venv/lib/python3.12/site-packages/starlette/middleware/cors.py:85: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:62: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
venv/lib/python3.12/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
venv/lib/python3.12/site-packages/starlette/routing.py:715: in __call__
    await self.middleware_stack(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:735: in app
    await route.handle(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:288: in handle
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:76: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
venv/lib/python3.12/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
venv/lib/python3.12/site-packages/starlette/routing.py:73: in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/fastapi/routing.py:327: in app
    content = await serialize_response(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def serialize_response(
        *,
        field: Optional[ModelField] = None,
        response_content: Any,
        include: Optional[IncEx] = None,
        exclude: Optional[IncEx] = None,
        by_alias: bool = True,
        exclude_unset: bool = False,
        exclude_defaults: bool = False,
        exclude_none: bool = False,
        is_coroutine: bool = True,
    ) -> Any:
        if field:
            errors = []
            if not hasattr(field, "serialize"):
                # pydantic v1
                response_content = _prepare_response_content(
                    response_content,
                    exclude_unset=exclude_unset,
                    exclude_defaults=exclude_defaults,
                    exclude_none=exclude_none,
                )
            if is_coroutine:
                value, errors_ = field.validate(response_content, {}, loc=("response",))
            else:
                value, errors_ = await run_in_threadpool(
                    field.validate, response_content, {}, loc=("response",)
                )
            if isinstance(errors_, list):
                errors.extend(errors_)
            elif errors_:
                errors.append(errors_)
            if errors:
>               raise ResponseValidationError(
                    errors=_normalize_errors(errors), body=response_content
                )
E               fastapi.exceptions.ResponseValidationError: 1 validation errors:
E                 {'type': 'value_error', 'loc': ('response', 'code'), 'msg': 'Value error, Code muss snake_case Format haben', 'input': 'InvalidCode', 'ctx': {'error': ValueError('Code muss snake_case Format haben')}}

venv/lib/python3.12/site-packages/fastapi/routing.py:176: ResponseValidationError
----------------------------- Captured stderr call -----------------------------
2025-09-04 12:31:30,654 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
2025-09-04 12:31:30,655 [INFO] [httpx] HTTP Request: PUT http://testserver/api/interest-groups/64 "HTTP/1.1 422 Unprocessable Entity"
2025-09-04 12:31:30,656 [INFO] [httpx] HTTP Request: PUT http://testserver/api/interest-groups/64 "HTTP/1.1 422 Unprocessable Entity"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: PUT http://testserver/api/interest-groups/64 "HTTP/1.1 422 Unprocessable Entity"
INFO     httpx:_client.py:1025 HTTP Request: PUT http://testserver/api/interest-groups/64 "HTTP/1.1 422 Unprocessable Entity"
___ TestUpdateInterestGroup.test_update_interest_group_duplicate_constraints ___

self = <test_update_interest_group.TestUpdateInterestGroup object at 0x11137d340>
client = <starlette.testclient.TestClient object at 0x111e20e00>

    def test_update_interest_group_duplicate_constraints(self, client):
        """Test: Duplikat-Constraints gelten auch bei Updates"""
        # Zwei Gruppen erstellen
        first_group_data = {
            "name": "First Group for Duplicate Test",
            "code": "first_duplicate_test"
        }
    
        second_group_data = {
            "name": "Second Group for Duplicate Test",
            "code": "second_duplicate_test"
        }
    
        first_response = client.post("/api/interest-groups", json=first_group_data)
        second_response = client.post("/api/interest-groups", json=second_group_data)
    
        assert first_response.status_code == 200
        assert second_response.status_code == 200
    
        first_group = first_response.json()
        second_group = second_response.json()
    
        # Versuch, den Code der ersten Gruppe auf den der zweiten zu setzen
        duplicate_code_update = {
            "code": "second_duplicate_test"
        }
    
        response = client.put(f"/api/interest-groups/{first_group['id']}", json=duplicate_code_update)
    
        # Bestehendes Verhalten: 422 für doppelte Codes
>       assert response.status_code == 422
E       assert 409 == 422
E        +  where 409 = <Response [409 Conflict]>.status_code

tests/characterization/interestgroups/test_update_interest_group.py:226: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-09-04 12:31:30,777 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
2025-09-04 12:31:30,779 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
2025-09-04 12:31:30,780 [INFO] [httpx] HTTP Request: PUT http://testserver/api/interest-groups/66 "HTTP/1.1 409 Conflict"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: PUT http://testserver/api/interest-groups/66 "HTTP/1.1 409 Conflict"
=============================== warnings summary ===============================
backend/app/database.py:63
  /Users/reiner/Documents/DocuMind-AI/backend/app/database.py:63: MovedIn20Warning: The ``declarative_base()`` function is now available as sqlalchemy.orm.declarative_base(). (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    Base = declarative_base()

<frozen importlib._bootstrap>:488
<frozen importlib._bootstrap>:488
  <frozen importlib._bootstrap>:488: DeprecationWarning: builtin type SwigPyPacked has no __module__ attribute

<frozen importlib._bootstrap>:488
<frozen importlib._bootstrap>:488
  <frozen importlib._bootstrap>:488: DeprecationWarning: builtin type SwigPyObject has no __module__ attribute

<frozen importlib._bootstrap>:488
  <frozen importlib._bootstrap>:488: DeprecationWarning: builtin type swigvarlink has no __module__ attribute

venv/lib/python3.12/site-packages/passlib/utils/__init__.py:854
  /Users/reiner/Documents/DocuMind-AI/venv/lib/python3.12/site-packages/passlib/utils/__init__.py:854: DeprecationWarning: 'crypt' is deprecated and slated for removal in Python 3.13
    from crypt import crypt as _crypt

venv/lib/python3.12/site-packages/pydantic/_internal/_config.py:291
  /Users/reiner/Documents/DocuMind-AI/venv/lib/python3.12/site-packages/pydantic/_internal/_config.py:291: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.9/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

backend/app/schemas_enhanced.py:130
  /Users/reiner/Documents/DocuMind-AI/backend/app/schemas_enhanced.py:130: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.9/migration/
    @validator('chunk_id', always=True)

backend/app/main.py:1185: 1 warning
tests/characterization/interestgroups/test_delete_interest_group.py: 4 warnings
tests/characterization/interestgroups/test_first_post_diagnostics.py: 2 warnings
tests/characterization/interestgroups/test_interest_group_business_rules.py: 12 warnings
tests/characterization/interestgroups/test_parity_endpoints.py: 4 warnings
tests/characterization/interestgroups/test_permission_handling.py: 10 warnings
tests/characterization/interestgroups/test_update_interest_group.py: 4 warnings
  /Users/reiner/Documents/DocuMind-AI/backend/app/main.py:1185: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

venv/lib/python3.12/site-packages/fastapi/applications.py:4495: 1 warning
tests/characterization/interestgroups/test_delete_interest_group.py: 4 warnings
tests/characterization/interestgroups/test_first_post_diagnostics.py: 2 warnings
tests/characterization/interestgroups/test_interest_group_business_rules.py: 12 warnings
tests/characterization/interestgroups/test_parity_endpoints.py: 4 warnings
tests/characterization/interestgroups/test_permission_handling.py: 10 warnings
tests/characterization/interestgroups/test_update_interest_group.py: 4 warnings
  /Users/reiner/Documents/DocuMind-AI/venv/lib/python3.12/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

tests/characterization/interestgroups/test_create_interest_group.py: 11 warnings
tests/characterization/interestgroups/test_delete_interest_group.py: 11 warnings
tests/characterization/interestgroups/test_delete_parity.py: 2 warnings
tests/characterization/interestgroups/test_first_post_diagnostics.py: 1 warning
tests/characterization/interestgroups/test_interest_group_business_rules.py: 6 warnings
tests/characterization/interestgroups/test_parity_endpoints.py: 5 warnings
tests/characterization/interestgroups/test_permission_handling.py: 5 warnings
tests/characterization/interestgroups/test_permission_parity.py: 7 warnings
tests/characterization/interestgroups/test_soft_delete_parity.py: 4 warnings
tests/characterization/interestgroups/test_statuscode_parity.py: 4 warnings
tests/characterization/interestgroups/test_update_interest_group.py: 18 warnings
  /Users/reiner/Documents/DocuMind-AI/venv/lib/python3.12/site-packages/pydantic/main.py:1114: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.9/migration/
    warnings.warn('The `dict` method is deprecated; use `model_dump` instead.', category=PydanticDeprecatedSince20)

tests/characterization/interestgroups/test_create_interest_group.py: 11 warnings
tests/characterization/interestgroups/test_delete_interest_group.py: 12 warnings
tests/characterization/interestgroups/test_delete_parity.py: 2 warnings
tests/characterization/interestgroups/test_first_post_diagnostics.py: 1 warning
tests/characterization/interestgroups/test_interest_group_business_rules.py: 11 warnings
tests/characterization/interestgroups/test_parity_endpoints.py: 3 warnings
tests/characterization/interestgroups/test_permission_handling.py: 10 warnings
tests/characterization/interestgroups/test_permission_parity.py: 5 warnings
tests/characterization/interestgroups/test_soft_delete_parity.py: 4 warnings
tests/characterization/interestgroups/test_statuscode_parity.py: 4 warnings
tests/characterization/interestgroups/test_update_interest_group.py: 8 warnings
  /Users/reiner/Documents/DocuMind-AI/venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:3596: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    return util.wrap_callable(lambda ctx: fn(), fn)  # type: ignore

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/characterization/interestgroups/test_database_schema.py::TestDatabaseSchema::test_interest_groups_table_structure
FAILED tests/characterization/interestgroups/test_database_schema.py::TestDatabaseSchema::test_interest_groups_unique_constraints
FAILED tests/characterization/interestgroups/test_database_schema.py::TestDatabaseSchema::test_interest_group_data_types
FAILED tests/characterization/interestgroups/test_database_schema.py::TestDatabaseSchema::test_interest_group_constraints_enforcement
FAILED tests/characterization/interestgroups/test_database_schema.py::TestDatabaseSchema::test_interest_group_table_size
FAILED tests/characterization/interestgroups/test_delete_interest_group.py::TestDeleteInterestGroup::test_delete_interest_group_soft_delete
FAILED tests/characterization/interestgroups/test_delete_interest_group.py::TestDeleteInterestGroup::test_delete_interest_group_multiple_deletions
FAILED tests/characterization/interestgroups/test_interest_group_business_rules.py::TestInterestGroupBusinessRules::test_interest_group_entity_creation
FAILED tests/characterization/interestgroups/test_interest_group_data_types.py::TestInterestGroupDataTypes::test_interest_group_data_types
FAILED tests/characterization/interestgroups/test_parity_endpoints.py::TestEndpointParity::test_get_interest_group_by_id_parity
FAILED tests/characterization/interestgroups/test_parity_endpoints.py::TestEndpointParity::test_create_interest_group_parity
FAILED tests/characterization/interestgroups/test_parity_endpoints.py::TestEndpointParity::test_delete_interest_group_parity
FAILED tests/characterization/interestgroups/test_permission_parity.py::TestPermissionParity::test_empty_permissions_parity
FAILED tests/characterization/interestgroups/test_permission_parity.py::TestPermissionParity::test_simple_permissions_parity
FAILED tests/characterization/interestgroups/test_permission_parity.py::TestPermissionParity::test_complex_permissions_parity
FAILED tests/characterization/interestgroups/test_permission_parity.py::TestPermissionParity::test_json_string_permissions_parity
FAILED tests/characterization/interestgroups/test_statuscode_parity.py::TestStatuscodeParity::test_duplicate_constraints_parity
FAILED tests/characterization/interestgroups/test_statuscode_parity.py::TestStatuscodeParity::test_invalid_content_type_parity
FAILED tests/characterization/interestgroups/test_statuscode_parity.py::TestStatuscodeParity::test_edge_cases_parity
FAILED tests/characterization/interestgroups/test_update_interest_group.py::TestUpdateInterestGroup::test_update_interest_group_validation_rules
FAILED tests/characterization/interestgroups/test_update_interest_group.py::TestUpdateInterestGroup::test_update_interest_group_duplicate_constraints
21 failed, 71 passed, 2 skipped, 228 warnings in 4.66s
sys:1: DeprecationWarning: builtin type swigvarlink has no __module__ attribute
