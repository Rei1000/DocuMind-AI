........F..F.F..F.........FFFFF...............F......................... [ 80%]
.......FF..FFFF..                                                        [100%]
=================================== FAILURES ===================================
___________ TestDatabaseSchema.test_interest_groups_table_structure ____________

self = <test_database_schema.TestDatabaseSchema object at 0x1222e9730>

    def test_interest_groups_table_structure(self):
        """Test: Tabellenstruktur entspricht dem erwarteten Schema"""
        with engine.connect() as connection:
            # Hole Tabellenstruktur
            result = connection.execute(text("PRAGMA table_info(interest_groups)"))
            columns = result.fetchall()
    
            # Erwartete Spalten
            expected_columns = {
                'id': {'type': 'INTEGER', 'notnull': 1, 'pk': 1},
                'name': {'type': 'VARCHAR', 'notnull': 1, 'pk': 0},
                'code': {'type': 'VARCHAR', 'notnull': 1, 'pk': 0},
                'description': {'type': 'TEXT', 'notnull': 0, 'pk': 0},
                'group_permissions': {'type': 'TEXT', 'notnull': 0, 'pk': 0},
                'ai_functionality': {'type': 'TEXT', 'notnull': 0, 'pk': 0},
                'typical_tasks': {'type': 'TEXT', 'notnull': 0, 'pk': 0},
                'is_external': {'type': 'BOOLEAN', 'notnull': 1, 'pk': 0},
                'is_active': {'type': 'BOOLEAN', 'notnull': 1, 'pk': 0},
                'created_at': {'type': 'DATETIME', 'notnull': 1, 'pk': 0}
            }
    
            # Prüfe jede erwartete Spalte
            for col_name, expected in expected_columns.items():
                col_found = False
                for col in columns:
                    if col[1] == col_name:
                        col_found = True
                        # Prüfe Typ (vereinfacht)
>                       assert col[2].upper() in expected['type'].upper(), f"Spalte {col_name} hat falschen Typ: {col[2]}"
E                       AssertionError: Spalte name hat falschen Typ: VARCHAR(100)
E                       assert 'VARCHAR(100)' in 'VARCHAR'
E                        +  where 'VARCHAR(100)' = <built-in method upper of str object at 0x149740cb0>()
E                        +    where <built-in method upper of str object at 0x149740cb0> = 'VARCHAR(100)'.upper
E                        +  and   'VARCHAR' = <built-in method upper of str object at 0x102b4e0a0>()
E                        +    where <built-in method upper of str object at 0x102b4e0a0> = 'VARCHAR'.upper

tests/characterization/interestgroups/test_database_schema.py:61: AssertionError
__________ TestDatabaseSchema.test_interest_groups_unique_constraints __________

self = <test_database_schema.TestDatabaseSchema object at 0x1222e8860>

    def test_interest_groups_unique_constraints(self):
        """Test: Unique-Constraints sind korrekt definiert"""
        with engine.connect() as connection:
            # Prüfe Unique-Constraints
            result = connection.execute(text("PRAGMA index_list(interest_groups)"))
            indexes = result.fetchall()
    
            # Finde Unique-Indizes
            unique_indexes = []
            for idx in indexes:
                if idx[2] == 1:  # unique = 1
                    unique_indexes.append(idx[1])
    
            # name und code sollten unique sein
>           assert 'ix_interest_groups_name' in unique_indexes, "Name-Index ist nicht unique"
E           AssertionError: Name-Index ist nicht unique
E           assert 'ix_interest_groups_name' in ['ix_interest_groups_code_unique', 'ix_interest_groups_name_unique']

tests/characterization/interestgroups/test_database_schema.py:118: AssertionError
______________ TestDatabaseSchema.test_interest_group_data_types _______________

self = <test_database_schema.TestDatabaseSchema object at 0x1222e9b50>

    def test_interest_group_data_types(self):
        """Test: Datentypen sind korrekt implementiert"""
        with engine.connect() as connection:
            # Erstelle eine Test-Gruppe
            test_data = {
                'name': 'Test Group for Schema',
                'code': 'test_schema_group',
                'description': 'Test-Beschreibung',
                'group_permissions': '["test_perm1", "test_perm2"]',
                'ai_functionality': 'Test AI Funktionen',
                'typical_tasks': 'Test-Aufgaben',
                'is_external': False,
                'is_active': True
            }
    
            # Insert über SQL um Datentypen zu testen
            insert_sql = """
                INSERT INTO interest_groups
                (name, code, description, group_permissions, ai_functionality, typical_tasks, is_external, is_active)
                VALUES (:name, :code, :description, :group_permissions, :ai_functionality, :typical_tasks, :is_external, :is_active)
            """
    
            connection.execute(text(insert_sql), test_data)
            connection.commit()
    
            # Hole die eingefügten Daten zurück
            result = connection.execute(text("""
                SELECT * FROM interest_groups WHERE code = 'test_schema_group'
            """))
            row = result.fetchone()
    
            assert row is not None, "Test-Daten wurden nicht eingefügt"
    
            # Prüfe Datentypen
            assert isinstance(row[1], str), f"name sollte String sein, ist {type(row[1])}"
            assert isinstance(row[2], str), f"code sollte String sein, ist {type(row[2])}"
            assert isinstance(row[3], str) or row[3] is None, f"description sollte String oder None sein, ist {type(row[3])}"
            assert isinstance(row[4], str) or row[4] is None, f"group_permissions sollte String oder None sein, ist {type(row[4])}"
            assert isinstance(row[5], str) or row[5] is None, f"ai_functionality sollte String oder None sein, ist {type(row[5])}"
            assert isinstance(row[6], str) or row[6] is None, f"typical_tasks sollte String oder None sein, ist {type(row[6])}"
>           assert isinstance(row[7], bool), f"is_external sollte Boolean sein, ist {type(row[7])}"
E           AssertionError: is_external sollte Boolean sein, ist <class 'int'>
E           assert False
E            +  where False = isinstance(0, bool)

tests/characterization/interestgroups/test_database_schema.py:172: AssertionError
______________ TestDatabaseSchema.test_interest_group_table_size _______________

self = <test_database_schema.TestDatabaseSchema object at 0x1222ea060>

    def test_interest_group_table_size(self):
        """Test: Tabelle hat die erwartete Größe"""
        with engine.connect() as connection:
            # Zähle alle Einträge
            result = connection.execute(text("SELECT COUNT(*) FROM interest_groups"))
            count = result.fetchone()[0]
    
            # Mindestens die 13 Standard-Gruppen sollten existieren
>           assert count >= 13, f"Tabelle sollte mindestens 13 Einträge haben, hat aber {count}"
E           AssertionError: Tabelle sollte mindestens 13 Einträge haben, hat aber 2
E           assert 2 >= 13

tests/characterization/interestgroups/test_database_schema.py:273: AssertionError
________ TestDeleteInterestGroup.test_delete_interest_group_soft_delete ________

self = <test_delete_interest_group.TestDeleteInterestGroup object at 0x1222eaed0>
client = <starlette.testclient.TestClient object at 0x14a4ca870>

    def test_delete_interest_group_soft_delete(self, client):
        """Test: Löschen ist ein Soft-Delete (is_active=False)"""
        # Erst eine Gruppe erstellen
        create_data = {
            "name": "Soft Delete Test Group",
            "code": "soft_delete_test_group",
            "description": "Test für Soft-Delete"
        }
    
        create_response = client.post("/api/interest-groups", json=create_data)
        assert create_response.status_code == 200
        created_group = create_response.json()
        group_id = created_group["id"]
    
        # Gruppe löschen
        delete_response = client.delete(f"/api/interest-groups/{group_id}")
>       assert delete_response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/characterization/interestgroups/test_delete_interest_group.py:99: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-09-04 09:54:20,135 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
2025-09-04 09:54:20,136 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
2025-09-04 09:54:20,137 [INFO] [httpx] HTTP Request: DELETE http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: DELETE http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
____ TestDeleteInterestGroup.test_delete_interest_group_response_structure _____

self = <test_delete_interest_group.TestDeleteInterestGroup object at 0x1222ea960>
client = <starlette.testclient.TestClient object at 0x14a4dadb0>

    def test_delete_interest_group_response_structure(self, client):
        """Test: Antwort des DELETE-Endpunkts hat korrekte Struktur"""
        # Erst eine Gruppe erstellen
        create_data = {
            "name": "Response Structure Test Group",
            "code": "response_structure_test",
            "description": "Test für Antwortstruktur"
        }
    
        create_response = client.post("/api/interest-groups", json=create_data)
        assert create_response.status_code == 200
        created_group = create_response.json()
        group_id = created_group["id"]
    
        # Gruppe löschen
        response = client.delete(f"/api/interest-groups/{group_id}")
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/characterization/interestgroups/test_delete_interest_group.py:131: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-09-04 09:54:20,140 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
2025-09-04 09:54:20,141 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
2025-09-04 09:54:20,143 [INFO] [httpx] HTTP Request: DELETE http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: DELETE http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
____ TestDeleteInterestGroup.test_delete_interest_group_multiple_deletions _____

self = <test_delete_interest_group.TestDeleteInterestGroup object at 0x1222e9c70>
client = <starlette.testclient.TestClient object at 0x14a4e81a0>

    def test_delete_interest_group_multiple_deletions(self, client):
        """Test: Mehrfache Löschungen der gleichen Gruppe"""
        # Erst eine Gruppe erstellen
        create_data = {
            "name": "Multiple Delete Test Group",
            "code": "multiple_delete_test",
            "description": "Test für mehrfache Löschungen"
        }
    
        create_response = client.post("/api/interest-groups", json=create_data)
        assert create_response.status_code == 200
        created_group = create_response.json()
        group_id = created_group["id"]
    
        # Gruppe zum ersten Mal löschen
        first_delete = client.delete(f"/api/interest-groups/{group_id}")
>       assert first_delete.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/characterization/interestgroups/test_delete_interest_group.py:157: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-09-04 09:54:20,145 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
2025-09-04 09:54:20,147 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
2025-09-04 09:54:20,148 [INFO] [httpx] HTTP Request: DELETE http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: DELETE http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
_ TestDeleteInterestGroup.test_delete_interest_group_no_authentication_required _

self = <test_delete_interest_group.TestDeleteInterestGroup object at 0x1222e9880>
client = <starlette.testclient.TestClient object at 0x14a4ea150>

    def test_delete_interest_group_no_authentication_required(self, client):
        """Test: Endpunkt ist ohne Authentifizierung erreichbar"""
        # Erst eine Gruppe erstellen
        create_data = {
            "name": "Auth Test Group",
            "code": "auth_test_group",
            "description": "Test für Authentifizierung"
        }
    
        create_response = client.post("/api/interest-groups", json=create_data)
        assert create_response.status_code == 200
        created_group = create_response.json()
        group_id = created_group["id"]
    
        # Gruppe ohne Authentifizierung löschen
        response = client.delete(f"/api/interest-groups/{group_id}")
    
        # Bestehendes Verhalten: Keine Authentifizierung erforderlich
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/characterization/interestgroups/test_delete_interest_group.py:183: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-09-04 09:54:20,151 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
2025-09-04 09:54:20,153 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
2025-09-04 09:54:20,154 [INFO] [httpx] HTTP Request: DELETE http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: DELETE http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
______ TestDeleteInterestGroup.test_delete_interest_group_cascade_effects ______

self = <test_delete_interest_group.TestDeleteInterestGroup object at 0x1222ebec0>
client = <starlette.testclient.TestClient object at 0x14a4c9850>

    def test_delete_interest_group_cascade_effects(self, client):
        """Test: Löschen einer Gruppe hat keine Cascade-Effekte auf andere Daten"""
        # Zwei Gruppen erstellen
        first_group_data = {
            "name": "First Group for Cascade Test",
            "code": "first_cascade_test"
        }
    
        second_group_data = {
            "name": "Second Group for Cascade Test",
            "code": "second_cascade_test"
        }
    
        first_response = client.post("/api/interest-groups", json=first_group_data)
        second_response = client.post("/api/interest-groups", json=second_group_data)
    
        assert first_response.status_code == 200
        assert second_response.status_code == 200
    
        first_group = first_response.json()
        second_group = second_response.json()
    
        # Erste Gruppe löschen
        delete_response = client.delete(f"/api/interest-groups/{first_group['id']}")
>       assert delete_response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/characterization/interestgroups/test_delete_interest_group.py:209: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-09-04 09:54:20,157 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
2025-09-04 09:54:20,158 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
2025-09-04 09:54:20,159 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
2025-09-04 09:54:20,160 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
2025-09-04 09:54:20,161 [INFO] [httpx] HTTP Request: DELETE http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: DELETE http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
__________ TestInterestGroupDataTypes.test_interest_group_data_types ___________

self = <sqlalchemy.engine.base.Connection object at 0x151a10110>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x103d36060>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x153d29040>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x14a206180>
parameters = [('Test Group for Schema', 'test_schema_group', 'Test-Beschreibung', '["test_perm1", "test_perm2"]', 'Test AI Funktionen', 'Test-Aufgaben', ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x103d36060>
cursor = <sqlite3.Cursor object at 0x1492777c0>
statement = '\n                INSERT INTO interest_groups \n                (name, code, description, group_permissions, ai_functionality, typical_tasks, is_external, is_active)\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n            '
parameters = ('Test Group for Schema', 'test_schema_group', 'Test-Beschreibung', '["test_perm1", "test_perm2"]', 'Test AI Funktionen', 'Test-Aufgaben', ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x153d29040>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: interest_groups.code

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: IntegrityError

The above exception was the direct cause of the following exception:

self = <test_interest_group_data_types.TestInterestGroupDataTypes object at 0x1492ad610>

    def test_interest_group_data_types(self):
        """Test: Datentypen sind korrekt implementiert"""
        with engine.connect() as connection:
            # Erstelle eine Test-Gruppe
            test_data = {
                'name': 'Test Group for Schema',
                'code': 'test_schema_group',
                'description': 'Test-Beschreibung',
                'group_permissions': '["test_perm1", "test_perm2"]',
                'ai_functionality': 'Test AI Funktionen',
                'typical_tasks': 'Test-Aufgaben',
                'is_external': False,
                'is_active': True
            }
    
            # Insert über SQL um Datentypen zu testen
            insert_sql = """
                INSERT INTO interest_groups
                (name, code, description, group_permissions, ai_functionality, typical_tasks, is_external, is_active)
                VALUES (:name, :code, :description, :group_permissions, :ai_functionality, :typical_tasks, :is_external, :is_active)
            """
    
>           connection.execute(text(insert_sql), test_data)

tests/characterization/interestgroups/test_interest_group_data_types.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x103d36060>
cursor = <sqlite3.Cursor object at 0x1492777c0>
statement = '\n                INSERT INTO interest_groups \n                (name, code, description, group_permissions, ai_functionality, typical_tasks, is_external, is_active)\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n            '
parameters = ('Test Group for Schema', 'test_schema_group', 'Test-Beschreibung', '["test_perm1", "test_perm2"]', 'Test AI Funktionen', 'Test-Aufgaben', ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x153d29040>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: interest_groups.code
E       [SQL: 
E                       INSERT INTO interest_groups 
E                       (name, code, description, group_permissions, ai_functionality, typical_tasks, is_external, is_active)
E                       VALUES (?, ?, ?, ?, ?, ?, ?, ?)
E                   ]
E       [parameters: ('Test Group for Schema', 'test_schema_group', 'Test-Beschreibung', '["test_perm1", "test_perm2"]', 'Test AI Funktionen', 'Test-Aufgaben', False, True)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: IntegrityError
______ TestUpdateInterestGroup.test_update_interest_group_with_valid_data ______

self = <test_update_interest_group.TestUpdateInterestGroup object at 0x1492d9ca0>
client = <starlette.testclient.TestClient object at 0x15390af60>

    def test_update_interest_group_with_valid_data(self, client):
        """Test: Endpunkt aktualisiert bestehende Interessensgruppe"""
        # Erst eine Gruppe erstellen
        create_data = {
            "name": "Group to Update",
            "code": "group_to_update",
            "description": "Ursprüngliche Beschreibung"
        }
    
        create_response = client.post("/api/interest-groups", json=create_data)
        assert create_response.status_code == 200
        created_group = create_response.json()
        group_id = created_group["id"]
    
        # Gruppe aktualisieren
        update_data = {
            "name": "Updated Group Name",
            "description": "Aktualisierte Beschreibung",
            "is_external": True
        }
    
        response = client.put(f"/api/interest-groups/{group_id}", json=update_data)
    
        # Bestehendes Verhalten dokumentieren
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/characterization/interestgroups/test_update_interest_group.py:35: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-09-04 09:54:23,330 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
2025-09-04 09:54:23,332 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
2025-09-04 09:54:23,334 [INFO] [httpx] HTTP Request: PUT http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: PUT http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
______ TestUpdateInterestGroup.test_update_interest_group_partial_update _______

self = <test_update_interest_group.TestUpdateInterestGroup object at 0x1492d9eb0>
client = <starlette.testclient.TestClient object at 0x1539434a0>

    def test_update_interest_group_partial_update(self, client):
        """Test: Partielle Updates funktionieren korrekt"""
        # Erst eine Gruppe erstellen
        create_data = {
            "name": "Partial Update Group",
            "code": "partial_update_group",
            "description": "Ursprüngliche Beschreibung",
            "ai_functionality": "Ursprüngliche AI Funktionen"
        }
    
        create_response = client.post("/api/interest-groups", json=create_data)
        assert create_response.status_code == 200
        created_group = create_response.json()
        group_id = created_group["id"]
    
        # Nur ein Feld aktualisieren
        update_data = {
            "description": "Neue Beschreibung"
        }
    
        response = client.put(f"/api/interest-groups/{group_id}", json=update_data)
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/characterization/interestgroups/test_update_interest_group.py:68: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-09-04 09:54:23,338 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
2025-09-04 09:54:23,340 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
2025-09-04 09:54:23,341 [INFO] [httpx] HTTP Request: PUT http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: PUT http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
_____ TestUpdateInterestGroup.test_update_interest_group_validation_rules ______

self = <test_update_interest_group.TestUpdateInterestGroup object at 0x1492da4e0>
client = <starlette.testclient.TestClient object at 0x153920200>

    def test_update_interest_group_validation_rules(self, client):
        """Test: Validierungsregeln gelten auch bei Updates"""
        # Erst eine Gruppe erstellen
        create_data = {
            "name": "Validation Test Group",
            "code": "validation_test_group",
            "description": "Test"
        }
    
        create_response = client.post("/api/interest-groups", json=create_data)
        assert create_response.status_code == 200
        created_group = create_response.json()
        group_id = created_group["id"]
    
        # Test mit zu kurzem Namen
        short_name_update = {
            "name": "A"  # Zu kurz (min 2 Zeichen)
        }
    
        response = client.put(f"/api/interest-groups/{group_id}", json=short_name_update)
    
        # Bestehendes Verhalten: 422 für ungültige Namen
        assert response.status_code == 422
    
        # Test mit zu langem Namen
        long_name_update = {
            "name": "A" * 101  # Zu lang (max 100 Zeichen)
        }
    
        response = client.put(f"/api/interest-groups/{group_id}", json=long_name_update)
    
        # Bestehendes Verhalten: 422 für zu lange Namen
        assert response.status_code == 422
    
        # Test mit ungültigem Code-Format
        invalid_code_update = {
            "code": "InvalidCode"  # Sollte snake_case sein
        }
    
        response = client.put(f"/api/interest-groups/{group_id}", json=invalid_code_update)
    
        # Bestehendes Verhalten: 422 für ungültige Codes
>       assert response.status_code == 422
E       assert 404 == 422
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/characterization/interestgroups/test_update_interest_group.py:148: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-09-04 09:54:23,350 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
2025-09-04 09:54:23,351 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
2025-09-04 09:54:23,353 [INFO] [httpx] HTTP Request: PUT http://testserver/api/interest-groups/0 "HTTP/1.1 422 Unprocessable Entity"
2025-09-04 09:54:23,354 [INFO] [httpx] HTTP Request: PUT http://testserver/api/interest-groups/0 "HTTP/1.1 422 Unprocessable Entity"
2025-09-04 09:54:23,355 [INFO] [httpx] HTTP Request: PUT http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: PUT http://testserver/api/interest-groups/0 "HTTP/1.1 422 Unprocessable Entity"
INFO     httpx:_client.py:1025 HTTP Request: PUT http://testserver/api/interest-groups/0 "HTTP/1.1 422 Unprocessable Entity"
INFO     httpx:_client.py:1025 HTTP Request: PUT http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
____ TestUpdateInterestGroup.test_update_interest_group_permissions_parsing ____

self = <test_update_interest_group.TestUpdateInterestGroup object at 0x1492da6f0>
client = <starlette.testclient.TestClient object at 0x153908f80>

    def test_update_interest_group_permissions_parsing(self, client):
        """Test: group_permissions werden bei Updates korrekt geparst"""
        # Erst eine Gruppe erstellen
        create_data = {
            "name": "Permissions Test Group",
            "code": "permissions_test_group",
            "group_permissions": ["original_perm1", "original_perm2"]
        }
    
        create_response = client.post("/api/interest-groups", json=create_data)
        assert create_response.status_code == 200
        created_group = create_response.json()
        group_id = created_group["id"]
    
        # Permissions als Liste aktualisieren
        list_update = {
            "group_permissions": ["new_perm1", "new_perm2", "new_perm3"]
        }
    
        response = client.put(f"/api/interest-groups/{group_id}", json=list_update)
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/characterization/interestgroups/test_update_interest_group.py:170: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-09-04 09:54:23,359 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
2025-09-04 09:54:23,360 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
2025-09-04 09:54:23,362 [INFO] [httpx] HTTP Request: PUT http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: PUT http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
___ TestUpdateInterestGroup.test_update_interest_group_duplicate_constraints ___

self = <test_update_interest_group.TestUpdateInterestGroup object at 0x1492da900>
client = <starlette.testclient.TestClient object at 0x14ce65430>

    def test_update_interest_group_duplicate_constraints(self, client):
        """Test: Duplikat-Constraints gelten auch bei Updates"""
        # Zwei Gruppen erstellen
        first_group_data = {
            "name": "First Group for Duplicate Test",
            "code": "first_duplicate_test"
        }
    
        second_group_data = {
            "name": "Second Group for Duplicate Test",
            "code": "second_duplicate_test"
        }
    
        first_response = client.post("/api/interest-groups", json=first_group_data)
        second_response = client.post("/api/interest-groups", json=second_group_data)
    
        assert first_response.status_code == 200
        assert second_response.status_code == 200
    
        first_group = first_response.json()
        second_group = second_response.json()
    
        # Versuch, den Code der ersten Gruppe auf den der zweiten zu setzen
        duplicate_code_update = {
            "code": "second_duplicate_test"
        }
    
        response = client.put(f"/api/interest-groups/{first_group['id']}", json=duplicate_code_update)
    
        # Bestehendes Verhalten: 422 für doppelte Codes
>       assert response.status_code == 422
E       assert 404 == 422
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/characterization/interestgroups/test_update_interest_group.py:224: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-09-04 09:54:23,366 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
2025-09-04 09:54:23,367 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
2025-09-04 09:54:23,368 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
2025-09-04 09:54:23,369 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
2025-09-04 09:54:23,370 [INFO] [httpx] HTTP Request: PUT http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: PUT http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
______ TestUpdateInterestGroup.test_update_interest_group_boolean_fields _______

self = <test_update_interest_group.TestUpdateInterestGroup object at 0x1492dab10>
client = <starlette.testclient.TestClient object at 0x14cd3d580>

    def test_update_interest_group_boolean_fields(self, client):
        """Test: Boolean-Felder werden korrekt aktualisiert"""
        # Erst eine Gruppe erstellen
        create_data = {
            "name": "Boolean Test Group",
            "code": "boolean_test_group",
            "is_external": False,
            "is_active": True
        }
    
        create_response = client.post("/api/interest-groups", json=create_data)
        assert create_response.status_code == 200
        created_group = create_response.json()
        group_id = created_group["id"]
    
        # Boolean-Felder aktualisieren
        boolean_update = {
            "is_external": True,
            "is_active": False
        }
    
        response = client.put(f"/api/interest-groups/{group_id}", json=boolean_update)
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/characterization/interestgroups/test_update_interest_group.py:258: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-09-04 09:54:23,374 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
2025-09-04 09:54:23,375 [INFO] [httpx] HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
2025-09-04 09:54:23,377 [INFO] [httpx] HTTP Request: PUT http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups "HTTP/1.1 307 Temporary Redirect"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/interest-groups/ "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: PUT http://testserver/api/interest-groups/0 "HTTP/1.1 404 Not Found"
=============================== warnings summary ===============================
backend/app/database.py:63
backend/app/database.py:63
  /Users/reiner/Documents/DocuMind-AI/backend/app/database.py:63: MovedIn20Warning: The ``declarative_base()`` function is now available as sqlalchemy.orm.declarative_base(). (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    Base = declarative_base()

<frozen importlib._bootstrap>:488
<frozen importlib._bootstrap>:488
  <frozen importlib._bootstrap>:488: DeprecationWarning: builtin type SwigPyPacked has no __module__ attribute

<frozen importlib._bootstrap>:488
<frozen importlib._bootstrap>:488
  <frozen importlib._bootstrap>:488: DeprecationWarning: builtin type SwigPyObject has no __module__ attribute

<frozen importlib._bootstrap>:488
  <frozen importlib._bootstrap>:488: DeprecationWarning: builtin type swigvarlink has no __module__ attribute

venv/lib/python3.12/site-packages/passlib/utils/__init__.py:854
  /Users/reiner/Documents/DocuMind-AI/venv/lib/python3.12/site-packages/passlib/utils/__init__.py:854: DeprecationWarning: 'crypt' is deprecated and slated for removal in Python 3.13
    from crypt import crypt as _crypt

venv/lib/python3.12/site-packages/pydantic/_internal/_config.py:291
venv/lib/python3.12/site-packages/pydantic/_internal/_config.py:291
  /Users/reiner/Documents/DocuMind-AI/venv/lib/python3.12/site-packages/pydantic/_internal/_config.py:291: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.9/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

backend/app/schemas_enhanced.py:130
backend/app/schemas_enhanced.py:130
  /Users/reiner/Documents/DocuMind-AI/backend/app/schemas_enhanced.py:130: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.9/migration/
    @validator('chunk_id', always=True)

backend/app/main.py:1185: 2 warnings
tests/characterization/interestgroups/test_interest_group_business_rules.py: 12 warnings
tests/characterization/interestgroups/test_parity_endpoints.py: 4 warnings
tests/characterization/interestgroups/test_permission_handling.py: 10 warnings
  /Users/reiner/Documents/DocuMind-AI/backend/app/main.py:1185: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

venv/lib/python3.12/site-packages/fastapi/applications.py:4495: 2 warnings
tests/characterization/interestgroups/test_interest_group_business_rules.py: 12 warnings
tests/characterization/interestgroups/test_parity_endpoints.py: 4 warnings
tests/characterization/interestgroups/test_permission_handling.py: 10 warnings
  /Users/reiner/Documents/DocuMind-AI/venv/lib/python3.12/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

tests/characterization/interestgroups/test_create_interest_group.py: 13 warnings
tests/characterization/interestgroups/test_delete_interest_group.py: 8 warnings
tests/characterization/interestgroups/test_interest_group_business_rules.py: 6 warnings
tests/characterization/interestgroups/test_parity_endpoints.py: 8 warnings
tests/characterization/interestgroups/test_permission_handling.py: 5 warnings
tests/characterization/interestgroups/test_permission_parity.py: 9 warnings
tests/characterization/interestgroups/test_soft_delete_parity.py: 4 warnings
tests/characterization/interestgroups/test_statuscode_parity.py: 9 warnings
tests/characterization/interestgroups/test_update_interest_group.py: 7 warnings
  /Users/reiner/Documents/DocuMind-AI/contexts/interestgroups/interface/router.py:107: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    created_at=datetime.utcnow(),

tests/characterization/interestgroups/test_create_interest_group.py: 13 warnings
tests/characterization/interestgroups/test_delete_interest_group.py: 8 warnings
tests/characterization/interestgroups/test_interest_group_business_rules.py: 6 warnings
tests/characterization/interestgroups/test_parity_endpoints.py: 8 warnings
tests/characterization/interestgroups/test_permission_handling.py: 5 warnings
tests/characterization/interestgroups/test_permission_parity.py: 9 warnings
tests/characterization/interestgroups/test_soft_delete_parity.py: 4 warnings
tests/characterization/interestgroups/test_statuscode_parity.py: 9 warnings
tests/characterization/interestgroups/test_update_interest_group.py: 7 warnings
  /Users/reiner/Documents/DocuMind-AI/contexts/interestgroups/interface/router.py:108: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    updated_at=datetime.utcnow()

tests/characterization/interestgroups/test_interest_group_business_rules.py: 6 warnings
tests/characterization/interestgroups/test_parity_endpoints.py: 1 warning
tests/characterization/interestgroups/test_permission_handling.py: 5 warnings
  /Users/reiner/Documents/DocuMind-AI/venv/lib/python3.12/site-packages/pydantic/main.py:1114: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.9/migration/
    warnings.warn('The `dict` method is deprecated; use `model_dump` instead.', category=PydanticDeprecatedSince20)

tests/characterization/interestgroups/test_interest_group_business_rules.py: 6 warnings
tests/characterization/interestgroups/test_parity_endpoints.py: 1 warning
tests/characterization/interestgroups/test_permission_handling.py: 5 warnings
  /Users/reiner/Documents/DocuMind-AI/venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:3596: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    return util.wrap_callable(lambda ctx: fn(), fn)  # type: ignore

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/characterization/interestgroups/test_database_schema.py::TestDatabaseSchema::test_interest_groups_table_structure
FAILED tests/characterization/interestgroups/test_database_schema.py::TestDatabaseSchema::test_interest_groups_unique_constraints
FAILED tests/characterization/interestgroups/test_database_schema.py::TestDatabaseSchema::test_interest_group_data_types
FAILED tests/characterization/interestgroups/test_database_schema.py::TestDatabaseSchema::test_interest_group_table_size
FAILED tests/characterization/interestgroups/test_delete_interest_group.py::TestDeleteInterestGroup::test_delete_interest_group_soft_delete
FAILED tests/characterization/interestgroups/test_delete_interest_group.py::TestDeleteInterestGroup::test_delete_interest_group_response_structure
FAILED tests/characterization/interestgroups/test_delete_interest_group.py::TestDeleteInterestGroup::test_delete_interest_group_multiple_deletions
FAILED tests/characterization/interestgroups/test_delete_interest_group.py::TestDeleteInterestGroup::test_delete_interest_group_no_authentication_required
FAILED tests/characterization/interestgroups/test_delete_interest_group.py::TestDeleteInterestGroup::test_delete_interest_group_cascade_effects
FAILED tests/characterization/interestgroups/test_interest_group_data_types.py::TestInterestGroupDataTypes::test_interest_group_data_types
FAILED tests/characterization/interestgroups/test_update_interest_group.py::TestUpdateInterestGroup::test_update_interest_group_with_valid_data
FAILED tests/characterization/interestgroups/test_update_interest_group.py::TestUpdateInterestGroup::test_update_interest_group_partial_update
FAILED tests/characterization/interestgroups/test_update_interest_group.py::TestUpdateInterestGroup::test_update_interest_group_validation_rules
FAILED tests/characterization/interestgroups/test_update_interest_group.py::TestUpdateInterestGroup::test_update_interest_group_permissions_parsing
FAILED tests/characterization/interestgroups/test_update_interest_group.py::TestUpdateInterestGroup::test_update_interest_group_duplicate_constraints
FAILED tests/characterization/interestgroups/test_update_interest_group.py::TestUpdateInterestGroup::test_update_interest_group_boolean_fields
16 failed, 73 passed, 230 warnings in 4.11s
sys:1: DeprecationWarning: builtin type swigvarlink has no __module__ attribute
